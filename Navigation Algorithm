// Fire Fighting Robot Coding


//NOTE that the sensors read higher numbers when the object, or wall, are closer. (The farther, the lower number it is,) 
int ldist; // LEFT SENSOR READ
int fdist; // FRONT SENSOR READ
int rdist; // RIGHT SENSOR READ
int fsense; // FLAME SENSOR READ

// PIN Assignments
//int switchPin = 12; // Pin for switch
int motor1Pin1 = 5; // left forwards (brown wire)
int motor1Pin2 = 4; // left backwards (white wire)
int motor2Pin1 = 6; // right forwards (red wire) 
int motor2Pin2 = 7; // right backwards (black wire)
/*
int groundPin = 8; // connect ground sensor to pin 8
int flamePin = 9; // connect flame sensor to pin 9
int fanPin = 10; // connect fan to pin 10
*/

int led = 11;

boolean currentState = HIGH;  

void setup(){ 
//  pinMode(switchPin, INPUT);
  pinMode(motor1Pin2, OUTPUT);
  pinMode(motor1Pin1, OUTPUT);
  pinMode(motor2Pin2, OUTPUT);
  pinMode(motor2Pin1, OUTPUT);
  //pinMode(fanPin, OUTPUT);
  
  /*
  pinMode(groundPin, OUTPUT);
  pinMode(flamePin, OUTPUT);
  pinMode(fanPin, OUTPUT);
  */
  
  pinMode(led, OUTPUT);
  Serial.begin(9600);
/*  while(digitalRead(switchPin) != HIGH) 
  {
      digitalWrite(led, LOW);
  }
*/
}



void loop() {
  //currentState = digitalRead(switchPin); //What is the current state? 
  // currentState = HIGH; //This line is to test the code without the switch
  
  //TURN ON: If the SWITCH is ON, then read sensors and move motors accordingly
  if (currentState == HIGH)
  { 
    digitalWrite(led, HIGH); // light turns on

      ldist = analogRead(1);
      fdist = analogRead(2);
      rdist = analogRead(3);

      
      fsense = analogRead(4);
            
      Serial.println();
      Serial.println("New Readings and Actions");
      Serial.print("Left"); Serial.print("       "); 
      Serial.print("Front"); Serial.print("       ");
      Serial.print("Right"); Serial.print("       ");
      Serial.print("Flame Sensor Reads"); Serial.print("       ");
      Serial.println();
      Serial.print(ldist); Serial.print("       ");
      Serial.print(fdist); Serial.print("       ");
      Serial.print(rdist); Serial.print("       ");
      Serial.print(fsense); Serial.print("       ");
      Serial.println();

      //return; //Test sensors 
      
      // README:
      // 1) Turning right is prioritized.
      //    If not right, go straight. If not right nor straight, turn left.

      //DEFAULT: GO FORWARD
      if ( (rdist > 200) && (fdist < 200) ) // if the rdist is close and front is open then go
      {
        Serial.println(" ");
        Serial.print("GO FORWARD");
        Serial.println(" ");
        break; 
        goForward();  
      }
      
      //STOP
      else if ( (fdist > 200) && (ldist > 200) && (rdist > 200) ) // but if fdist is too close, stop
      {
        Serial.println(" ");
        Serial.print("STOP");
        Serial.println(" ");
        break;
        Stop();
      }
      
      //TURN RIGHT
      if (rdist < 200) // if the right dist is far, then turn right 
      {
        Serial.println(" ");
        Serial.println("TURN RIGHT");
        Serial.println(" ");
        break;
        turnRight();
        
        
        goForward();
      }

      else if ( (rdist > 200) && (fdist > 200) )
      {
        Serial.println(" ");
        Serial.println("TURN LEFT");
        Serial.println("");
        break;
        turnLeft();

        goForward();
      }


      /*
      
      //GO FORWARD
      else if ((fdist < 400) && (fdist < ldist) && (fdist < rdist)) //If the distance of the front is farther than the distances of left and right,
      {                                                            //go forward
        Serial.println(" ");
        Serial.println("Go Forward");
        goForward();
      } 
  
      //TURN BACK (TURN RIGHT 180 DEGREES)
      else if (fdist == 400 && ldist == 400 && rdist == 400)
      {
        Serial.println(" ");
        Serial.println("Left Turn");
        //If go right turns the bot 90 degrees clockwise, calling twice
        //will turn it 180 degrees clockwise, and it will proceed to move forward.
        Stop();
        turnRight();
        turnRight();
        goForward();
      }
  
      
      //TURN LEFT
      else if (rdist < 500) 
        {
          //Right Sensor detects something less 23cm away
          // Result need to TURN Left 90 degrees and GO FORWARD
          Serial.println("Left Turn");
          Serial.println();
          turnLeft();
          goForward();
        }
        
        else if (ldist < 400) 
        {
          //Left Sensor detects something less 23cm away
          // Result need to TURN Right
          turnRight();
          goForward();        
        }

        */
      
    }

    //TURN OFF  the motors if the SWITCH is OFF
    else if(currentState == LOW)
    { 
      Serial.println("OFF");
      Stop();
      digitalWrite(led, LOW); // ADDED NOW  
  }



 
}

//********************************************
//Defining Robot's Potential Actions as functions
//Stop, move forward, turn left, turn right
//Call different order of functions depending on the potential
//situations in the maze (3-way fork, left only, etc.)
//********************************************

void Stop()
  {
  digitalWrite(motor1Pin1, LOW);
  digitalWrite(motor1Pin2, LOW);
  digitalWrite(motor2Pin1, LOW);
  digitalWrite(motor2Pin2, LOW);  
  }

void goForward()
  {
  digitalWrite(motor1Pin1, HIGH);
  digitalWrite(motor1Pin2, LOW);
  digitalWrite(motor2Pin1, HIGH);
  digitalWrite(motor2Pin2, LOW);  
  }

//SUGGESTION:
//Turns 90 degrees clockwise, and continues forward
//Not exactly sure how many seconds that would take...Some delay

void turnRight()
  {
  digitalWrite(motor1Pin1, HIGH);
  digitalWrite(motor1Pin2, LOW);
  digitalWrite(motor2Pin1, LOW);
  digitalWrite(motor2Pin2, HIGH); 
  }

//Turns 90 degrees counterclockwise, and continues forward

void turnLeft()
  {
  digitalWrite(motor1Pin1, LOW);
  digitalWrite(motor1Pin2, HIGH);
  digitalWrite(motor2Pin1, LOW);
  digitalWrite(motor2Pin2, HIGH);  
  }
